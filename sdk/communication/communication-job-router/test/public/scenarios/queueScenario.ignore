// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import { assert } from "chai";
import { RouterAdministrationClient, RouterClient, RouterJob, } from "../../../src";
import { Context } from "mocha";
import {
  classificationPolicyRequest,
  distributionPolicyRequest,
  exceptionPolicyRequest,
  jobRequest,
  queueRequest,
  classificationPolicyConditional,
  conditionalScenarioJob,
  classificationPolicyPassthrough,
  passthroughScenarioJob,
  classificationPolicyCombined,
  frenchJob,
  englishJob,
  englishQueue,
  frenchQueue
} from "../utils/testData";
import { createRecordedRouterClientWithConnectionString } from "../../internal/utils/mockClient";
import { timeoutMs } from "../utils/constants";

describe("RouterClient", function() {
  const sleepMs: number = 1500;
  let administrationClient: RouterAdministrationClient;
  let client: RouterClient;

  // HACK: Intentionally block to avoid 'duplicate sequence number' error from service
  function sleep(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  describe("Queue Scenario", function() {
    this.beforeAll(async function(this: Context) {
      ({ client, administrationClient } = await createRecordedRouterClientWithConnectionString(this));

      await administrationClient.createDistributionPolicy(
        distributionPolicyRequest.id!,
        distributionPolicyRequest
      );
      await administrationClient.createExceptionPolicy(exceptionPolicyRequest.id!, exceptionPolicyRequest);
      await administrationClient.createQueue(queueRequest.id!, queueRequest);
      await administrationClient.createClassificationPolicy(
        classificationPolicyRequest.id!,
        classificationPolicyRequest
      );
      await client.createJob(jobRequest.id!, jobRequest);
    });

    this.afterAll(async function(this: Context) {
      await sleep(sleepMs);
      await client.deleteJob(jobRequest.id!);
      await administrationClient.deleteClassificationPolicy(classificationPolicyRequest.id!);
      await administrationClient.deleteQueue(queueRequest.id!);
      await administrationClient.deleteExceptionPolicy(exceptionPolicyRequest.id!);
      await administrationClient.deleteDistributionPolicy(distributionPolicyRequest.id!);
    });

    it("should complete with conditional selector", async () => {
      await administrationClient.createClassificationPolicy(classificationPolicyConditional.id!, classificationPolicyConditional);
      await client.createJob(conditionalScenarioJob.id!, conditionalScenarioJob);

      let job: RouterJob = conditionalScenarioJob;
      while (job.jobStatus !== "queued") {
        job = await client.getJob(conditionalScenarioJob.id!);
      }

      assert.equal(job.jobStatus, "queued");
      assert.equal(job.queueId, queueRequest.id);
    }).timeout(timeoutMs);

    it("should complete with passthrough selector", async () => {
      await administrationClient.createClassificationPolicy(classificationPolicyPassthrough.id!, classificationPolicyPassthrough);
      await client.createJob(passthroughScenarioJob.id!, passthroughScenarioJob);

      let job: RouterJob = passthroughScenarioJob;
      while (job.jobStatus !== "queued") {
        job = await client.getJob(passthroughScenarioJob.id!);
      }

      assert.equal(job.jobStatus, "queued");
      assert.equal(job.queueId, queueRequest.id);
    }).timeout(timeoutMs);

    it("should complete with combined selectors", async () => {
      await administrationClient.createClassificationPolicy(classificationPolicyCombined.id!, classificationPolicyCombined);
      await administrationClient.createQueue(englishQueue.id!, englishQueue);
      await administrationClient.createQueue(frenchQueue.id!, frenchQueue);

      let job1: RouterJob = englishJob;
      await client.createJob(englishJob.id!, englishJob);
      while (job1.jobStatus !== "queued") {
        job1 = await client.getJob(englishJob.id!);
      }

      let job2: RouterJob = frenchJob;
      await client.createJob(frenchJob.id!, frenchJob);
      while (job2.jobStatus !== "queued") {
        job2 = await client.getJob(frenchJob.id!);
      }

      assert.equal(job1.jobStatus, "queued");
      assert.equal(job2.jobStatus, "queued");
      assert.equal(job1.queueId, englishQueue.id!);
      assert.equal(job2.queueId, frenchQueue.id!);
    }).timeout(timeoutMs);
  });
});
